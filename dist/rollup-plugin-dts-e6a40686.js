"use strict";var F=Object.defineProperty,A=Object.defineProperties;var $=Object.getOwnPropertyDescriptors;var I=Object.getOwnPropertySymbols;var L=Object.prototype.hasOwnProperty,K=Object.prototype.propertyIsEnumerable;var P=(n,e,t)=>e in n?F(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,N=(n,e)=>{for(var t in e||(e={}))L.call(e,t)&&P(n,t,e[t]);if(I)for(var t of I(e))K.call(e,t)&&P(n,t,e[t]);return n},b=(n,e)=>A(n,$(e));var require$$2=require("module"),path=require("path"),MagicString=require("magic-string");function _interopDefaultLegacy(n){return n&&typeof n=="object"&&"default"in n?n:{default:n}}function _interopNamespace(n){if(n&&n.__esModule)return n;var e=Object.create(null);return n&&Object.keys(n).forEach(function(t){if(t!=="default"){var r=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:function(){return n[t]}})}}),e.default=n,Object.freeze(e)}var path__namespace=_interopNamespace(path),MagicString__default=_interopDefaultLegacy(MagicString),require$1=require;function getLocalTypescriptPath(){const n=process.cwd();try{return require$1.resolve("typescript",{paths:[n]})}catch{throw new Error(`Could not find \`typescript\` in ${n}`)}}var ts=require$1(getLocalTypescriptPath());const dts=".d.ts",formatHost={getCurrentDirectory:()=>ts.sys.getCurrentDirectory(),getNewLine:()=>ts.sys.newLine,getCanonicalFileName:ts.sys.useCaseSensitiveFileNames?n=>n:n=>n.toLowerCase()},DEFAULT_OPTIONS={declaration:!0,noEmit:!1,emitDeclarationOnly:!0,noEmitOnError:!0,checkJs:!1,declarationMap:!1,skipLibCheck:!0,preserveSymlinks:!0,target:ts.ScriptTarget.ESNext};function getCompilerOptions(n,e){const t=N(N({},DEFAULT_OPTIONS),e);let r=path__namespace.dirname(n),i=[];const a=ts.findConfigFile(r,ts.sys.fileExists);if(!a)return{dtsFiles:i,dirName:r,compilerOptions:t};r=path__namespace.dirname(a);const{config:c,error:o}=ts.readConfigFile(a,ts.sys.readFile);if(o)return console.error(ts.formatDiagnostic(o,formatHost)),{dtsFiles:i,dirName:r,compilerOptions:t};const{fileNames:l,options:u,errors:p}=ts.parseJsonConfigFileContent(c,ts.sys,r);return i=l.filter(m=>m.endsWith(dts)),p.length?(console.error(ts.formatDiagnostics(p,formatHost)),{dtsFiles:i,dirName:r,compilerOptions:t}):{dtsFiles:i,dirName:r,compilerOptions:N(N({},u),t)}}function createProgram$1(n,e){const{dtsFiles:t,compilerOptions:r}=getCompilerOptions(n,e);return ts.createProgram([n].concat(Array.from(t)),r,ts.createCompilerHost(r,!0))}function createPrograms(n,e){const t=[];let r=[],i=new Set,a="",c={};for(let o of n){if(o.endsWith(dts))continue;o=path__namespace.resolve(o);const l=getCompilerOptions(o,e);if(l.dtsFiles.forEach(i.add,i),!r.length){r.push(o),{dirName:a,compilerOptions:c}=l;continue}if(l.dirName===a)r.push(o);else{const u=ts.createCompilerHost(c,!0),p=ts.createProgram(r.concat(Array.from(i)),c,u);t.push(p),r=[o],{dirName:a,compilerOptions:c}=l}}if(r.length){const o=ts.createCompilerHost(c,!0),l=ts.createProgram(r.concat(Array.from(i)),c,o);t.push(l)}return t}function getCodeFrame(){let n;try{return{codeFrameColumns:n}=require$1("@babel/code-frame"),n}catch{try{return{codeFrameColumns:n}=require$$2.createRequire(typeof document=="undefined"?new(require("url")).URL("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("rollup-plugin-dts-e6a40686.js",document.baseURI).href)("@babel/code-frame"),n}catch{}}}function getLocation(n){const e=n.getSourceFile(),t=e.getLineAndCharacterOfPosition(n.getStart()),r=e.getLineAndCharacterOfPosition(n.getEnd());return{start:{line:t.line+1,column:t.character+1},end:{line:r.line+1,column:r.character+1}}}function frameNode(n){const e=getCodeFrame(),r=n.getSourceFile().getFullText(),i=getLocation(n);return e?`
`+e(r,i,{highlightCode:!0}):`
${i.start.line}:${i.start.column}: \`${n.getFullText().trim()}\``}class UnsupportedSyntaxError extends Error{constructor(e,t="Syntax not yet supported"){super(`${t}
${frameNode(e)}`)}}class NamespaceFixer{constructor(e){this.sourceFile=e}findNamespaces(){const e=[],t={};for(const r of this.sourceFile.statements){const i={start:r.getStart(),end:r.getEnd()};if(ts.isEmptyStatement(r)){e.unshift({name:"",exports:[],location:i});continue}if((ts.isImportDeclaration(r)||ts.isExportDeclaration(r))&&r.moduleSpecifier&&ts.isStringLiteral(r.moduleSpecifier)){let{text:p}=r.moduleSpecifier;if(p.startsWith(".")&&(p.endsWith(".d.ts")||p.endsWith(".d.cts")||p.endsWith(".d.mts"))){let m=r.moduleSpecifier.getStart()+1,g=r.moduleSpecifier.getEnd()-1;e.unshift({name:"",exports:[],location:{start:m,end:g},textBeforeCodeAfter:p.replace(/\.d\.ts$/,".js").replace(/\.d\.cts$/,".cjs").replace(/\.d\.mts$/,".mjs")})}}if(ts.isModuleDeclaration(r)&&r.body&&ts.isModuleBlock(r.body)){for(const p of r.body.statements)if(ts.isExportDeclaration(p)&&p.exportClause){if(ts.isNamespaceExport(p.exportClause))continue;for(const m of p.exportClause.elements)m.propertyName&&m.propertyName.getText()==m.name.getText()&&e.unshift({name:"",exports:[],location:{start:m.propertyName.getEnd(),end:m.name.getEnd()}})}}if(ts.isClassDeclaration(r)?t[r.name.getText()]={type:"class",generics:r.typeParameters}:ts.isFunctionDeclaration(r)?t[r.name.getText()]={type:"function"}:ts.isInterfaceDeclaration(r)?t[r.name.getText()]={type:"interface",generics:r.typeParameters}:ts.isTypeAliasDeclaration(r)?t[r.name.getText()]={type:"type",generics:r.typeParameters}:ts.isModuleDeclaration(r)&&ts.isIdentifier(r.name)?t[r.name.getText()]={type:"namespace"}:ts.isEnumDeclaration(r)&&(t[r.name.getText()]={type:"enum"}),!ts.isVariableStatement(r))continue;const{declarations:a}=r.declarationList;if(a.length!==1)continue;const c=a[0],o=c.name.getText();if(!c.initializer||!ts.isCallExpression(c.initializer)){t[o]={type:"var"};continue}const l=c.initializer.arguments[0];if(!c.initializer.expression.getFullText().includes("/*#__PURE__*/Object.freeze")||!ts.isObjectLiteralExpression(l))continue;const u=[];for(const p of l.properties){if(!ts.isPropertyAssignment(p)||!(ts.isIdentifier(p.name)||ts.isStringLiteral(p.name))||p.name.text!=="__proto__"&&!ts.isIdentifier(p.initializer))throw new UnsupportedSyntaxError(p,"Expected a property assignment");p.name.text!=="__proto__"&&u.push({exportedName:p.name.text,localName:p.initializer.getText()})}e.unshift({name:o,exports:u,location:i})}return{namespaces:e,itemTypes:t}}fix(){var e;let t=this.sourceFile.getFullText();const{namespaces:r,itemTypes:i}=this.findNamespaces();for(const a of r){const c=t.slice(a.location.end);t=t.slice(0,a.location.start);for(const{exportedName:o,localName:l}of a.exports)if(o===l){const{type:u,generics:p}=i[l]||{};if(u==="interface"||u==="type"){const m=renderTypeParams(p);t+=`type ${a.name}_${o}${m.in} = ${l}${m.out};
`}else if(u==="enum"||u==="class"){const m=renderTypeParams(p);t+=`type ${a.name}_${o}${m.in} = ${l}${m.out};
`,t+=`declare const ${a.name}_${o}: typeof ${l};
`}else t+=`declare const ${a.name}_${o}: typeof ${l};
`}if(a.name){t+=`declare namespace ${a.name} {
`,t+=`  export {
`;for(const{exportedName:o,localName:l}of a.exports)o===l?t+=`    ${a.name}_${o} as ${o},
`:t+=`    ${l} as ${o},
`;t+=`  };
`,t+="}"}t+=(e=a.textBeforeCodeAfter)!==null&&e!==void 0?e:"",t+=c}return t}}function renderTypeParams(n){return!n||!n.length?{in:"",out:""}:{in:`<${n.map(e=>e.getText()).join(", ")}>`,out:`<${n.map(e=>e.name.getText()).join(", ")}>`}}let IDs=1;function createProgram(n){return withStartEnd({type:"Program",sourceType:"module",body:[]},{start:n.getFullStart(),end:n.getEnd()})}function createReference(n){return{type:"AssignmentPattern",left:{type:"Identifier",name:String(IDs++)},right:n}}function createIdentifier(n){return withStartEnd({type:"Identifier",name:n.getText()},n)}function createIIFE(n){const e=withStartEnd({type:"FunctionExpression",id:null,params:[],body:{type:"BlockStatement",body:[]}},n),t=withStartEnd({type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",name:String(IDs++)},arguments:[e],optional:!1}},n);return{fn:e,iife:t}}function createDeclaration(n,e){return withStartEnd({type:"FunctionDeclaration",id:withStartEnd({type:"Identifier",name:ts.idText(n)},n),params:[],body:{type:"BlockStatement",body:[]}},e)}function convertExpression(n){if(ts.isLiteralExpression(n))return{type:"Literal",value:n.text};if(ts.isPropertyAccessExpression(n)){if(ts.isPrivateIdentifier(n.name))throw new UnsupportedSyntaxError(n.name);return withStartEnd({type:"MemberExpression",computed:!1,optional:!1,object:convertExpression(n.expression),property:convertExpression(n.name)},{start:n.expression.getStart(),end:n.name.getEnd()})}if(ts.isIdentifier(n))return createIdentifier(n);if(n.kind==ts.SyntaxKind.NullKeyword)return{type:"Literal",value:null};throw new UnsupportedSyntaxError(n)}function withStartEnd(n,e){let t="start"in e?e:{start:e.getStart(),end:e.getEnd()};return Object.assign(n,t)}function matchesModifier(n,e){return(ts.getCombinedModifierFlags(n)&e)===e}function preProcess({sourceFile:n}){const e=new MagicString__default.default(n.getFullText()),t=new Set,r=new Set;let i="";const a=new Map,c=new Map;for(const s of n.statements){if(ts.isEmptyStatement(s)){e.remove(s.getStart(),s.getEnd());continue}if(ts.isEnumDeclaration(s)||ts.isFunctionDeclaration(s)||ts.isInterfaceDeclaration(s)||ts.isClassDeclaration(s)||ts.isTypeAliasDeclaration(s)||ts.isModuleDeclaration(s)){if(s.name){const f=s.name.getText();t.add(f),matchesModifier(s,ts.ModifierFlags.ExportDefault)?i=f:matchesModifier(s,ts.ModifierFlags.Export)&&r.add(f),s.flags&ts.NodeFlags.GlobalAugmentation||D(f,[getStart(s),getEnd(s)])}ts.isModuleDeclaration(s)&&duplicateExports(e,s),fixModifiers(e,s)}else if(ts.isVariableStatement(s)){const{declarations:f}=s.declarationList,y=matchesModifier(s,ts.ModifierFlags.Export);for(const h of s.declarationList.declarations)if(ts.isIdentifier(h.name)){const x=h.name.getText();t.add(x),y&&r.add(x)}if(fixModifiers(e,s),f.length==1){const h=f[0];ts.isIdentifier(h.name)&&D(h.name.getText(),[getStart(s),getEnd(s)])}else{const h=f.slice(),x=h.shift();D(x.name.getText(),[getStart(s),x.getEnd()]);for(const T of h)ts.isIdentifier(T.name)&&D(T.name.getText(),[T.getFullStart(),T.getEnd()])}const{flags:d}=s.declarationList,E=`declare ${d&ts.NodeFlags.Let?"let":d&ts.NodeFlags.Const?"const":"var"} `,w=s.declarationList.getChildren().find(h=>h.kind===ts.SyntaxKind.SyntaxList).getChildren();let S=0;for(const h of w)if(h.kind===ts.SyntaxKind.CommaToken)S=h.getStart(),e.remove(S,h.getEnd());else if(S){e.appendLeft(S,`;
`);const x=h.getFullStart(),T=e.slice(x,h.getStart());let C=T.length-T.trimStart().length;C?e.overwrite(x,x+C,E):e.appendLeft(x,E)}}}for(const s of n.statements)if(p(s),!!matchesModifier(s,ts.ModifierFlags.ExportDefault)&&(ts.isFunctionDeclaration(s)||ts.isClassDeclaration(s))){if(s.name)continue;i||(i=g("export_default"));const f=s.getChildren(),y=f.findIndex(w=>w.kind===ts.SyntaxKind.ClassKeyword||w.kind===ts.SyntaxKind.FunctionKeyword),d=f[y],v=f[y+1];v.kind>=ts.SyntaxKind.FirstPunctuation&&v.kind<=ts.SyntaxKind.LastPunctuation?e.appendLeft(v.getStart(),i):e.appendRight(d.getEnd(),` ${i}`)}for(const s of c.values()){const y=s.pop()[0];for(const d of s)e.move(d[0],d[1],y)}i&&e.append(`
export default ${i};
`),r.size&&e.append(`
export { ${[...r].join(", ")} };
`);for(const[s,f]of a.entries())e.prepend(`import * as ${f} from "${s}";
`);const o=n.getLineStarts(),l=new Set;for(const s of n.typeReferenceDirectives){l.add(s.fileName);const{line:f}=n.getLineAndCharacterOfPosition(s.pos),y=o[f];let d=n.getLineEndOfPosition(s.pos);e.slice(d,d+1)==`
`&&(d+=1),e.remove(y,d)}const u=new Set;for(const s of n.referencedFiles){u.add(path__namespace.join(path__namespace.dirname(n.fileName),s.fileName));const{line:f}=n.getLineAndCharacterOfPosition(s.pos),y=o[f];let d=n.getLineEndOfPosition(s.pos);e.slice(d,d+1)==`
`&&(d+=1),e.remove(y,d)}return{code:e,typeReferences:l,fileReferences:u};function p(s){if(ts.forEachChild(s,p),ts.isImportTypeNode(s)){if(!ts.isLiteralTypeNode(s.argument)||!ts.isStringLiteral(s.argument.literal))throw new UnsupportedSyntaxError(s,"inline imports should have a literal argument");const f=s.argument.literal.text,y=s.getChildren(),d=y.find(S=>S.kind===ts.SyntaxKind.ImportKeyword).getStart();let v=s.getEnd();const E=y.find(S=>S.kind===ts.SyntaxKind.DotToken||S.kind===ts.SyntaxKind.LessThanToken);E&&(v=E.getStart());const w=m(f);e.overwrite(d,v,w)}}function m(s){let f=a.get(s);return f||(f=g(s.replace(/[^a-zA-Z0-9_$]/g,()=>"_")),a.set(s,f)),f}function g(s){let f=s;for(;t.has(f);)f=`_${f}`;return t.add(f),f}function D(s,f){let y=c.get(s);if(!y)y=[f],c.set(s,y);else{const d=y[y.length-1];d[1]===f[0]?d[1]=f[1]:y.push(f)}}}function fixModifiers(n,e){var t;let r=!1;const i=ts.isClassDeclaration(e)||ts.isFunctionDeclaration(e)||ts.isModuleDeclaration(e)||ts.isVariableStatement(e);for(const a of(t=e.modifiers)!==null&&t!==void 0?t:[])switch(a.kind){case ts.SyntaxKind.ExportKeyword:case ts.SyntaxKind.DefaultKeyword:n.remove(a.getStart(),a.getEnd()+1);break;case ts.SyntaxKind.DeclareKeyword:r=!0}i&&!r&&n.appendRight(e.getStart(),"declare ")}function duplicateExports(n,e){if(!(!e.body||!ts.isModuleBlock(e.body))){for(const t of e.body.statements)if(ts.isExportDeclaration(t)&&t.exportClause){if(ts.isNamespaceExport(t.exportClause))continue;for(const r of t.exportClause.elements)r.propertyName||n.appendLeft(r.name.getEnd(),` as ${r.name.getText()}`)}}}function getStart(n){const e=n.getFullStart();return e+(newlineAt(n,e)?1:0)}function getEnd(n){const e=n.getEnd();return e+(newlineAt(n,e)?1:0)}function newlineAt(n,e){return n.getSourceFile().getFullText()[e]==`
`}const IGNORE_TYPENODES=new Set([ts.SyntaxKind.LiteralType,ts.SyntaxKind.VoidKeyword,ts.SyntaxKind.UnknownKeyword,ts.SyntaxKind.AnyKeyword,ts.SyntaxKind.BooleanKeyword,ts.SyntaxKind.NumberKeyword,ts.SyntaxKind.StringKeyword,ts.SyntaxKind.ObjectKeyword,ts.SyntaxKind.NullKeyword,ts.SyntaxKind.UndefinedKeyword,ts.SyntaxKind.SymbolKeyword,ts.SyntaxKind.NeverKeyword,ts.SyntaxKind.ThisKeyword,ts.SyntaxKind.ThisType,ts.SyntaxKind.BigIntKeyword]);class DeclarationScope{constructor({id:e,range:t}){if(this.scopes=[],e)this.declaration=createDeclaration(e,t);else{const{iife:r,fn:i}=createIIFE(t);this.iife=r,this.declaration=i}}pushScope(){this.scopes.push(new Set)}popScope(e=1){for(let t=0;t<e;t++)this.scopes.pop()}pushTypeVariable(e){var t;const r=e.getText();(t=this.scopes[this.scopes.length-1])===null||t===void 0||t.add(r)}pushRaw(e){this.declaration.params.push(e)}pushReference(e){let t;if(e.type==="Identifier"?t=e.name:e.type==="MemberExpression"&&e.object.type==="Identifier"&&(t=e.object.name),t){for(const r of this.scopes)if(r.has(t))return}this.pushRaw(createReference(e))}pushIdentifierReference(e){this.pushReference(createIdentifier(e))}convertEntityName(e){return ts.isIdentifier(e)?createIdentifier(e):withStartEnd({type:"MemberExpression",computed:!1,optional:!1,object:this.convertEntityName(e.left),property:createIdentifier(e.right)},e)}convertPropertyAccess(e){if(!ts.isIdentifier(e.expression)&&!ts.isPropertyAccessExpression(e.expression))throw new UnsupportedSyntaxError(e.expression);if(ts.isPrivateIdentifier(e.name))throw new UnsupportedSyntaxError(e.name);let t=ts.isIdentifier(e.expression)?createIdentifier(e.expression):this.convertPropertyAccess(e.expression);return withStartEnd({type:"MemberExpression",computed:!1,optional:!1,object:t,property:createIdentifier(e.name)},e)}convertComputedPropertyName(e){if(!e.name||!ts.isComputedPropertyName(e.name))return;const{expression:t}=e.name;if(!ts.isLiteralExpression(t)){if(ts.isIdentifier(t))return this.pushReference(createIdentifier(t));if(ts.isPropertyAccessExpression(t))return this.pushReference(this.convertPropertyAccess(t));throw new UnsupportedSyntaxError(t)}}convertParametersAndType(e){this.convertComputedPropertyName(e);const t=this.convertTypeParameters(e.typeParameters);for(const r of e.parameters)this.convertTypeNode(r.type);this.convertTypeNode(e.type),this.popScope(t)}convertHeritageClauses(e){for(const t of e.heritageClauses||[])for(const r of t.types)this.pushReference(convertExpression(r.expression)),this.convertTypeArguments(r)}convertTypeArguments(e){if(!!e.typeArguments)for(const t of e.typeArguments)this.convertTypeNode(t)}convertMembers(e){for(const t of e){if(ts.isPropertyDeclaration(t)||ts.isPropertySignature(t)||ts.isIndexSignatureDeclaration(t)){this.convertComputedPropertyName(t),this.convertTypeNode(t.type);continue}if(ts.isMethodDeclaration(t)||ts.isMethodSignature(t)||ts.isConstructorDeclaration(t)||ts.isConstructSignatureDeclaration(t)||ts.isCallSignatureDeclaration(t)||ts.isGetAccessorDeclaration(t)||ts.isSetAccessorDeclaration(t))this.convertParametersAndType(t);else throw new UnsupportedSyntaxError(t)}}convertTypeParameters(e){if(!e)return 0;for(const t of e)this.convertTypeNode(t.constraint),this.convertTypeNode(t.default),this.pushScope(),this.pushTypeVariable(t.name);return e.length}convertTypeNode(e){if(!!e&&!IGNORE_TYPENODES.has(e.kind)){if(ts.isTypeReferenceNode(e)){this.pushReference(this.convertEntityName(e.typeName)),this.convertTypeArguments(e);return}if(ts.isTypeLiteralNode(e))return this.convertMembers(e.members);if(ts.isArrayTypeNode(e))return this.convertTypeNode(e.elementType);if(ts.isTupleTypeNode(e)){for(const t of e.elements)this.convertTypeNode(t);return}if(ts.isNamedTupleMember(e)||ts.isParenthesizedTypeNode(e)||ts.isTypeOperatorNode(e)||ts.isTypePredicateNode(e))return this.convertTypeNode(e.type);if(ts.isUnionTypeNode(e)||ts.isIntersectionTypeNode(e)){for(const t of e.types)this.convertTypeNode(t);return}if(ts.isMappedTypeNode(e)){const{typeParameter:t,type:r,nameType:i}=e;this.convertTypeNode(t.constraint),this.pushScope(),this.pushTypeVariable(t.name),this.convertTypeNode(r),i&&this.convertTypeNode(i),this.popScope();return}if(ts.isConditionalTypeNode(e)){this.convertTypeNode(e.checkType),this.pushScope(),this.convertTypeNode(e.extendsType),this.convertTypeNode(e.trueType),this.convertTypeNode(e.falseType),this.popScope();return}if(ts.isIndexedAccessTypeNode(e)){this.convertTypeNode(e.objectType),this.convertTypeNode(e.indexType);return}if(ts.isFunctionOrConstructorTypeNode(e)){this.convertParametersAndType(e);return}if(ts.isTypeQueryNode(e)){this.pushReference(this.convertEntityName(e.exprName));return}if(ts.isRestTypeNode(e)){this.convertTypeNode(e.type);return}if(ts.isOptionalTypeNode(e)){this.convertTypeNode(e.type);return}if(ts.isTemplateLiteralTypeNode(e)){for(const t of e.templateSpans)this.convertTypeNode(t.type);return}if(ts.isInferTypeNode(e)){this.pushTypeVariable(e.typeParameter.name);return}else throw new UnsupportedSyntaxError(e)}}convertNamespace(e,t=!1){if(this.pushScope(),t&&e.body&&ts.isModuleDeclaration(e.body)){this.convertNamespace(e.body,!0);return}if(!e.body||!ts.isModuleBlock(e.body))throw new UnsupportedSyntaxError(e,'namespace must have a "ModuleBlock" body.');const{statements:r}=e.body;for(const i of r){if(ts.isEnumDeclaration(i)||ts.isFunctionDeclaration(i)||ts.isClassDeclaration(i)||ts.isInterfaceDeclaration(i)||ts.isTypeAliasDeclaration(i)||ts.isModuleDeclaration(i)){if(i.name&&ts.isIdentifier(i.name))this.pushTypeVariable(i.name);else throw new UnsupportedSyntaxError(i,"non-Identifier name not supported");continue}if(ts.isVariableStatement(i)){for(const a of i.declarationList.declarations)if(ts.isIdentifier(a.name))this.pushTypeVariable(a.name);else throw new UnsupportedSyntaxError(a,"non-Identifier name not supported");continue}if(!ts.isExportDeclaration(i))throw new UnsupportedSyntaxError(i,"namespace child (hoisting) not supported yet")}for(const i of r){if(ts.isVariableStatement(i)){for(const a of i.declarationList.declarations)a.type&&this.convertTypeNode(a.type);continue}if(ts.isFunctionDeclaration(i)){this.convertParametersAndType(i);continue}if(ts.isInterfaceDeclaration(i)||ts.isClassDeclaration(i)){const a=this.convertTypeParameters(i.typeParameters);this.convertHeritageClauses(i),this.convertMembers(i.members),this.popScope(a);continue}if(ts.isTypeAliasDeclaration(i)){const a=this.convertTypeParameters(i.typeParameters);this.convertTypeNode(i.type),this.popScope(a);continue}if(ts.isModuleDeclaration(i)){this.convertNamespace(i,t);continue}if(!ts.isEnumDeclaration(i))if(ts.isExportDeclaration(i)){if(i.exportClause){if(ts.isNamespaceExport(i.exportClause))throw new UnsupportedSyntaxError(i.exportClause);for(const a of i.exportClause.elements){const c=a.propertyName||a.name;this.pushIdentifierReference(c)}}}else throw new UnsupportedSyntaxError(i,"namespace child (walking) not supported yet")}this.popScope()}}function convert({sourceFile:n}){return new Transformer(n).transform()}class Transformer{constructor(e){this.sourceFile=e,this.declarations=new Map,this.ast=createProgram(e);for(const t of e.statements)this.convertStatement(t)}transform(){return{ast:this.ast}}pushStatement(e){this.ast.body.push(e)}createDeclaration(e,t){const r={start:e.getFullStart(),end:e.getEnd()};if(!t){const o=new DeclarationScope({range:r});return this.pushStatement(o.iife),o}const i=t.getText(),a=new DeclarationScope({id:t,range:r}),c=this.declarations.get(i);if(c){c.pushIdentifierReference(t),c.declaration.end=r.end;let o=this.ast.body.findIndex(l=>l==c.declaration);for(let l=o+1;l<this.ast.body.length;l++){const u=this.ast.body[l];u.start=u.end=r.end}}else this.pushStatement(a.declaration),this.declarations.set(i,a);return c||a}convertStatement(e){if(ts.isEnumDeclaration(e))return this.convertEnumDeclaration(e);if(ts.isFunctionDeclaration(e))return this.convertFunctionDeclaration(e);if(ts.isInterfaceDeclaration(e)||ts.isClassDeclaration(e))return this.convertClassOrInterfaceDeclaration(e);if(ts.isTypeAliasDeclaration(e))return this.convertTypeAliasDeclaration(e);if(ts.isVariableStatement(e))return this.convertVariableStatement(e);if(ts.isExportDeclaration(e)||ts.isExportAssignment(e))return this.convertExportDeclaration(e);if(ts.isModuleDeclaration(e))return this.convertNamespaceDeclaration(e);if(e.kind==ts.SyntaxKind.NamespaceExportDeclaration)return this.removeStatement(e);if(ts.isImportDeclaration(e)||ts.isImportEqualsDeclaration(e))return this.convertImportDeclaration(e);throw new UnsupportedSyntaxError(e)}removeStatement(e){this.pushStatement(withStartEnd({type:"ExpressionStatement",expression:{type:"Literal",value:"pls remove me"}},e))}convertNamespaceDeclaration(e){if(e.flags&ts.NodeFlags.GlobalAugmentation||!ts.isIdentifier(e.name)){this.createDeclaration(e).convertNamespace(e,!0);return}const r=this.createDeclaration(e,e.name);r.pushIdentifierReference(e.name),r.convertNamespace(e)}convertEnumDeclaration(e){this.createDeclaration(e,e.name).pushIdentifierReference(e.name)}convertFunctionDeclaration(e){if(!e.name)throw new UnsupportedSyntaxError(e,"FunctionDeclaration should have a name");const t=this.createDeclaration(e,e.name);t.pushIdentifierReference(e.name),t.convertParametersAndType(e)}convertClassOrInterfaceDeclaration(e){if(!e.name)throw new UnsupportedSyntaxError(e,"ClassDeclaration / InterfaceDeclaration should have a name");const t=this.createDeclaration(e,e.name),r=t.convertTypeParameters(e.typeParameters);t.convertHeritageClauses(e),t.convertMembers(e.members),t.popScope(r)}convertTypeAliasDeclaration(e){const t=this.createDeclaration(e,e.name),r=t.convertTypeParameters(e.typeParameters);t.convertTypeNode(e.type),t.popScope(r)}convertVariableStatement(e){const{declarations:t}=e.declarationList;if(t.length!==1)throw new UnsupportedSyntaxError(e,"VariableStatement with more than one declaration not yet supported");for(const r of t){if(!ts.isIdentifier(r.name))throw new UnsupportedSyntaxError(e,"VariableDeclaration must have a name");this.createDeclaration(e,r.name).convertTypeNode(r.type)}}convertExportDeclaration(e){if(ts.isExportAssignment(e)){this.pushStatement(withStartEnd({type:"ExportDefaultDeclaration",declaration:convertExpression(e.expression)},e));return}const t=e.moduleSpecifier?convertExpression(e.moduleSpecifier):void 0;if(!e.exportClause)this.pushStatement(withStartEnd({type:"ExportAllDeclaration",source:t,exported:null},e));else if(ts.isNamespaceExport(e.exportClause))this.pushStatement(withStartEnd({type:"ExportAllDeclaration",source:t,exported:createIdentifier(e.exportClause.name)},e));else{const r=[];for(const i of e.exportClause.elements)r.push(this.convertExportSpecifier(i));this.pushStatement(withStartEnd({type:"ExportNamedDeclaration",declaration:null,specifiers:r,source:t},e))}}convertImportDeclaration(e){if(ts.isImportEqualsDeclaration(e)){if(!ts.isExternalModuleReference(e.moduleReference))throw new UnsupportedSyntaxError(e,"ImportEquals should have a literal source.");this.pushStatement(withStartEnd({type:"ImportDeclaration",specifiers:[{type:"ImportDefaultSpecifier",local:createIdentifier(e.name)}],source:convertExpression(e.moduleReference.expression)},e));return}const t=convertExpression(e.moduleSpecifier),r=e.importClause&&e.importClause.namedBindings?this.convertNamedImportBindings(e.importClause.namedBindings):[];e.importClause&&e.importClause.name&&r.push({type:"ImportDefaultSpecifier",local:createIdentifier(e.importClause.name)}),this.pushStatement(withStartEnd({type:"ImportDeclaration",specifiers:r,source:t},e))}convertNamedImportBindings(e){return ts.isNamedImports(e)?e.elements.map(t=>{const r=createIdentifier(t.name),i=t.propertyName?createIdentifier(t.propertyName):r;return{type:"ImportSpecifier",local:r,imported:i}}):[{type:"ImportNamespaceSpecifier",local:createIdentifier(e.name)}]}convertExportSpecifier(e){const t=createIdentifier(e.name);return{type:"ExportSpecifier",exported:t,local:e.propertyName?createIdentifier(e.propertyName):t}}}function parse(n,e){return ts.createSourceFile(n,e,ts.ScriptTarget.Latest,!0)}const transform=()=>{const n=new Map,e=new Map;return{name:"dts-transform",options(t){const{onwarn:r}=t;return b(N({},t),{onwarn(i,a){i.code!="CIRCULAR_DEPENDENCY"&&(r?r(i,a):a(i))},treeshake:{moduleSideEffects:"no-external",propertyReadSideEffects:!0,unknownGlobalSideEffects:!1}})},outputOptions(t){return b(N({},t),{chunkFileNames:t.chunkFileNames||"[name]-[hash].d.ts",entryFileNames:t.entryFileNames||"[name].d.ts",format:"es",exports:"named",compact:!1,freeze:!0,interop:!1,namespaceToStringTag:!1,strict:!1})},transform(t,r){let i=parse(r,t);const a=preProcess({sourceFile:i});n.set(i.fileName,a.typeReferences),e.set(i.fileName,a.fileReferences),t=a.code.toString(),i=parse(r,t);const c=convert({sourceFile:i});return process.env.DTS_DUMP_AST&&(console.log(r),console.log(t),console.log(JSON.stringify(c.ast.body,void 0,2))),{code:t,ast:c.ast,map:a.code.generateMap()}},renderChunk(t,r,i){const a=parse(r.fileName,t),c=new NamespaceFixer(a),o=new Set,l=new Set;for(const u of Object.keys(r.modules)){for(const p of n.get(u.split("\\").join("/"))||[])o.add(p);for(const p of e.get(u.split("\\").join("/"))||[]){const m=i.file&&path__namespace.dirname(i.file)||r.facadeModuleId&&path__namespace.dirname(r.facadeModuleId)||".";let g=path__namespace.relative(m,p).split("\\").join("/");g[0]!=="."&&(g="./"+g),l.add(g)}}return t=writeBlock(Array.from(l,u=>`/// <reference path="${u}" />`)),t+=writeBlock(Array.from(o,u=>`/// <reference types="${u}" />`)),t+=c.fix(),{code:t,map:{mappings:""}}}}};function writeBlock(n){return n.length?n.join(`
`)+`
`:""}const tsx=/\.(t|j)sx?$/,plugin=(n={})=>{const e=transform(),{respectExternal:t=!1,compilerOptions:r={}}=n;let i=[];function a(c){let o,l;return!i.length&&c.endsWith(dts)?o=!0:(l=i.find(u=>o=u.getSourceFile(c)),!l&&ts.sys.fileExists(c)&&(i.push(l=createProgram$1(c,r)),o=l.getSourceFile(c))),{source:o,program:l}}return{name:"dts",options(c){let{input:o=[]}=c;if(!Array.isArray(o))o=typeof o=="string"?[o]:Object.values(o);else if(o.length>1){c.input={};for(const l of o){let u=l.replace(/((\.d)?\.(t|j)sx?)$/,"");path__namespace.isAbsolute(l)?u=path__namespace.basename(u):u=path__namespace.normalize(u),c.input[u]=l}}return i=createPrograms(Object.values(o),r),e.options.call(this,c)},outputOptions:e.outputOptions,transform(c,o){const l=(s,f)=>(typeof s=="object"&&(c=s.getFullText()),e.transform.call(this,c,f));if(!tsx.test(o))return null;if(o.endsWith(dts)){const{source:s}=a(o);return s?l(s,o):null}const u=o.replace(tsx,dts);let p=a(u);if(p.source)return l(p.source,u);if(p=a(o),typeof p.source!="object"||!p.program)return null;let m;const{emitSkipped:g,diagnostics:D}=p.program.emit(p.source,(s,f)=>{c=f,m=l(!0,u)},void 0,!0);if(g){const s=D.filter(f=>f.category===ts.DiagnosticCategory.Error);s.length&&(console.error(ts.formatDiagnostics(s,formatHost)),this.error("Failed to compile. Check the logs above."))}return m},resolveId(c,o){if(!o)return;o=o.split("\\").join("/");const{resolvedModule:l}=ts.nodeModuleNameResolver(c,o,r,ts.sys);if(!!l)return!t&&l.isExternalLibraryImport?{id:c,external:!0}:{id:path__namespace.resolve(l.resolvedFileName)}},renderChunk:e.renderChunk}};exports.default=plugin;
