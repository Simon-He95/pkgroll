"use strict";var Q=Object.defineProperty,Z=Object.defineProperties;var X=Object.getOwnPropertyDescriptors;var O=Object.getOwnPropertySymbols;var ee=Object.prototype.hasOwnProperty,te=Object.prototype.propertyIsEnumerable;var V=(i,e,t)=>e in i?Q(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,C=(i,e)=>{for(var t in e||(e={}))ee.call(e,t)&&V(i,t,e[t]);if(O)for(var t of O(e))te.call(e,t)&&V(i,t,e[t]);return i},K=(i,e)=>Z(i,X(e));var re=require("module"),ne=require("path"),ie=require("magic-string");function se(i){return i&&typeof i=="object"&&"default"in i?i:{default:i}}function ae(i){if(i&&i.__esModule)return i;var e=Object.create(null);return i&&Object.keys(i).forEach(function(t){if(t!=="default"){var n=Object.getOwnPropertyDescriptor(i,t);Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:function(){return i[t]}})}}),e.default=i,Object.freeze(e)}var T=ae(ne),oe=se(ie),M=require;function ce(){const i=process.cwd();try{return M.resolve("typescript",{paths:[i]})}catch{throw new Error(`Could not find \`typescript\` in ${i}`)}}var r=M(ce());const $=".d.ts",R={getCurrentDirectory:()=>r.sys.getCurrentDirectory(),getNewLine:()=>r.sys.newLine,getCanonicalFileName:r.sys.useCaseSensitiveFileNames?i=>i:i=>i.toLowerCase()},le={declaration:!0,noEmit:!1,emitDeclarationOnly:!0,noEmitOnError:!0,checkJs:!1,declarationMap:!1,skipLibCheck:!0,preserveSymlinks:!0,target:r.ScriptTarget.ESNext};function q(i,e){const t=C(C({},le),e);let n=T.dirname(i),s=[];const o=r.findConfigFile(n,r.sys.fileExists);if(!o)return{dtsFiles:s,dirName:n,compilerOptions:t};n=T.dirname(o);const{config:l,error:c}=r.readConfigFile(o,r.sys.readFile);if(c)return console.error(r.formatDiagnostic(c,R)),{dtsFiles:s,dirName:n,compilerOptions:t};const{fileNames:p,options:m,errors:f}=r.parseJsonConfigFileContent(l,r.sys,n);return s=p.filter(d=>d.endsWith($)),f.length?(console.error(r.formatDiagnostics(f,R)),{dtsFiles:s,dirName:n,compilerOptions:t}):{dtsFiles:s,dirName:n,compilerOptions:C(C({},m),t)}}function pe(i,e){const{dtsFiles:t,compilerOptions:n}=q(i,e);return r.createProgram([i].concat(Array.from(t)),n,r.createCompilerHost(n,!0))}function fe(i,e){const t=[];let n=[],s=new Set,o="",l={};for(let c of i){if(c.endsWith($))continue;c=T.resolve(c);const p=q(c,e);if(p.dtsFiles.forEach(s.add,s),!n.length){n.push(c),{dirName:o,compilerOptions:l}=p;continue}if(p.dirName===o)n.push(c);else{const m=r.createCompilerHost(l,!0),f=r.createProgram(n.concat(Array.from(s)),l,m);t.push(f),n=[c],{dirName:o,compilerOptions:l}=p}}if(n.length){const c=r.createCompilerHost(l,!0),p=r.createProgram(n.concat(Array.from(s)),l,c);t.push(p)}return t}function ue(){let i;try{return{codeFrameColumns:i}=M("@babel/code-frame"),i}catch{try{return{codeFrameColumns:i}=re.createRequire(typeof document=="undefined"?new(require("url")).URL("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("rollup-plugin-dts-2a55828f.js",document.baseURI).href)("@babel/code-frame"),i}catch{}}}function me(i){const e=i.getSourceFile(),t=e.getLineAndCharacterOfPosition(i.getStart()),n=e.getLineAndCharacterOfPosition(i.getEnd());return{start:{line:t.line+1,column:t.character+1},end:{line:n.line+1,column:n.character+1}}}function de(i){const e=ue(),n=i.getSourceFile().getFullText(),s=me(i);return e?`
`+e(n,s,{highlightCode:!0}):`
${s.start.line}:${s.start.column}: \`${i.getFullText().trim()}\``}class h extends Error{constructor(e,t="Syntax not yet supported"){super(`${t}
${de(e)}`)}}class ye{constructor(e){this.sourceFile=e}findNamespaces(){const e=[],t={};for(const n of this.sourceFile.statements){const s={start:n.getStart(),end:n.getEnd()};if(r.isEmptyStatement(n)){e.unshift({name:"",exports:[],location:s});continue}if((r.isImportDeclaration(n)||r.isExportDeclaration(n))&&n.moduleSpecifier&&r.isStringLiteral(n.moduleSpecifier)){let{text:f}=n.moduleSpecifier;if(f.startsWith(".")&&(f.endsWith(".d.ts")||f.endsWith(".d.cts")||f.endsWith(".d.mts"))){let d=n.moduleSpecifier.getStart()+1,N=n.moduleSpecifier.getEnd()-1;e.unshift({name:"",exports:[],location:{start:d,end:N},textBeforeCodeAfter:f.replace(/\.d\.ts$/,".js").replace(/\.d\.cts$/,".cjs").replace(/\.d\.mts$/,".mjs")})}}if(r.isModuleDeclaration(n)&&n.body&&r.isModuleBlock(n.body)){for(const f of n.body.statements)if(r.isExportDeclaration(f)&&f.exportClause){if(r.isNamespaceExport(f.exportClause))continue;for(const d of f.exportClause.elements)d.propertyName&&d.propertyName.getText()==d.name.getText()&&e.unshift({name:"",exports:[],location:{start:d.propertyName.getEnd(),end:d.name.getEnd()}})}}if(r.isClassDeclaration(n)?t[n.name.getText()]={type:"class",generics:n.typeParameters}:r.isFunctionDeclaration(n)?t[n.name.getText()]={type:"function"}:r.isInterfaceDeclaration(n)?t[n.name.getText()]={type:"interface",generics:n.typeParameters}:r.isTypeAliasDeclaration(n)?t[n.name.getText()]={type:"type",generics:n.typeParameters}:r.isModuleDeclaration(n)&&r.isIdentifier(n.name)?t[n.name.getText()]={type:"namespace"}:r.isEnumDeclaration(n)&&(t[n.name.getText()]={type:"enum"}),!r.isVariableStatement(n))continue;const{declarations:o}=n.declarationList;if(o.length!==1)continue;const l=o[0],c=l.name.getText();if(!l.initializer||!r.isCallExpression(l.initializer)){t[c]={type:"var"};continue}const p=l.initializer.arguments[0];if(!l.initializer.expression.getFullText().includes("/*#__PURE__*/Object.freeze")||!r.isObjectLiteralExpression(p))continue;const m=[];for(const f of p.properties){if(!r.isPropertyAssignment(f)||!(r.isIdentifier(f.name)||r.isStringLiteral(f.name))||f.name.text!=="__proto__"&&!r.isIdentifier(f.initializer))throw new h(f,"Expected a property assignment");f.name.text!=="__proto__"&&m.push({exportedName:f.name.text,localName:f.initializer.getText()})}e.unshift({name:c,exports:m,location:s})}return{namespaces:e,itemTypes:t}}fix(){var e;let t=this.sourceFile.getFullText();const{namespaces:n,itemTypes:s}=this.findNamespaces();for(const o of n){const l=t.slice(o.location.end);t=t.slice(0,o.location.start);for(const{exportedName:c,localName:p}of o.exports)if(c===p){const{type:m,generics:f}=s[p]||{};if(m==="interface"||m==="type"){const d=B(f);t+=`type ${o.name}_${c}${d.in} = ${p}${d.out};
`}else if(m==="enum"||m==="class"){const d=B(f);t+=`type ${o.name}_${c}${d.in} = ${p}${d.out};
`,t+=`declare const ${o.name}_${c}: typeof ${p};
`}else t+=`declare const ${o.name}_${c}: typeof ${p};
`}if(o.name){t+=`declare namespace ${o.name} {
`,t+=`  export {
`;for(const{exportedName:c,localName:p}of o.exports)c===p?t+=`    ${o.name}_${c} as ${c},
`:t+=`    ${p} as ${c},
`;t+=`  };
`,t+="}"}t+=(e=o.textBeforeCodeAfter)!==null&&e!==void 0?e:"",t+=l}return t}}function B(i){return!i||!i.length?{in:"",out:""}:{in:`<${i.map(e=>e.getText()).join(", ")}>`,out:`<${i.map(e=>e.name.getText()).join(", ")}>`}}let U=1;function he(i){return S({type:"Program",sourceType:"module",body:[]},{start:i.getFullStart(),end:i.getEnd()})}function ge(i){return{type:"AssignmentPattern",left:{type:"Identifier",name:String(U++)},right:i}}function v(i){return S({type:"Identifier",name:i.getText()},i)}function xe(i){const e=S({type:"FunctionExpression",id:null,params:[],body:{type:"BlockStatement",body:[]}},i),t=S({type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",name:String(U++)},arguments:[e],optional:!1}},i);return{fn:e,iife:t}}function Se(i,e){return S({type:"FunctionDeclaration",id:S({type:"Identifier",name:r.idText(i)},i),params:[],body:{type:"BlockStatement",body:[]}},e)}function I(i){if(r.isLiteralExpression(i))return{type:"Literal",value:i.text};if(r.isPropertyAccessExpression(i)){if(r.isPrivateIdentifier(i.name))throw new h(i.name);return S({type:"MemberExpression",computed:!1,optional:!1,object:I(i.expression),property:I(i.name)},{start:i.expression.getStart(),end:i.name.getEnd()})}if(r.isIdentifier(i))return v(i);if(i.kind==r.SyntaxKind.NullKeyword)return{type:"Literal",value:null};throw new h(i)}function S(i,e){let t="start"in e?e:{start:e.getStart(),end:e.getEnd()};return Object.assign(i,t)}function L(i,e){return(r.getCombinedModifierFlags(i)&e)===e}function ve({sourceFile:i}){const e=new oe.default(i.getFullText()),t=new Set,n=new Set;let s="";const o=new Map,l=new Map;for(const a of i.statements){if(r.isEmptyStatement(a)){e.remove(a.getStart(),a.getEnd());continue}if(r.isEnumDeclaration(a)||r.isFunctionDeclaration(a)||r.isInterfaceDeclaration(a)||r.isClassDeclaration(a)||r.isTypeAliasDeclaration(a)||r.isModuleDeclaration(a)){if(a.name){const u=a.name.getText();t.add(u),L(a,r.ModifierFlags.ExportDefault)?s=u:L(a,r.ModifierFlags.Export)&&n.add(u),a.flags&r.NodeFlags.GlobalAugmentation||P(u,[_(a),W(a)])}r.isModuleDeclaration(a)&&Te(e,a),z(e,a)}else if(r.isVariableStatement(a)){const{declarations:u}=a.declarationList,g=L(a,r.ModifierFlags.Export);for(const x of a.declarationList.declarations)if(r.isIdentifier(x.name)){const D=x.name.getText();t.add(D),g&&n.add(D)}if(z(e,a),u.length==1){const x=u[0];r.isIdentifier(x.name)&&P(x.name.getText(),[_(a),W(a)])}else{const x=u.slice(),D=x.shift();P(D.name.getText(),[_(a),D.getEnd()]);for(const b of x)r.isIdentifier(b.name)&&P(b.name.getText(),[b.getFullStart(),b.getEnd()])}const{flags:y}=a.declarationList,F=`declare ${y&r.NodeFlags.Let?"let":y&r.NodeFlags.Const?"const":"var"} `,A=a.declarationList.getChildren().find(x=>x.kind===r.SyntaxKind.SyntaxList).getChildren();let E=0;for(const x of A)if(x.kind===r.SyntaxKind.CommaToken)E=x.getStart(),e.remove(E,x.getEnd());else if(E){e.appendLeft(E,`;
`);const D=x.getFullStart(),b=e.slice(D,x.getStart());let j=b.length-b.trimStart().length;j?e.overwrite(D,D+j,F):e.appendLeft(D,F)}}}for(const a of i.statements)if(f(a),!!L(a,r.ModifierFlags.ExportDefault)&&(r.isFunctionDeclaration(a)||r.isClassDeclaration(a))){if(a.name)continue;s||(s=N("export_default"));const u=a.getChildren(),g=u.findIndex(A=>A.kind===r.SyntaxKind.ClassKeyword||A.kind===r.SyntaxKind.FunctionKeyword),y=u[g],w=u[g+1];w.kind>=r.SyntaxKind.FirstPunctuation&&w.kind<=r.SyntaxKind.LastPunctuation?e.appendLeft(w.getStart(),s):e.appendRight(y.getEnd(),` ${s}`)}for(const a of l.values()){const g=a.pop()[0];for(const y of a)e.move(y[0],y[1],g)}s&&e.append(`
export default ${s};
`),n.size&&e.append(`
export { ${[...n].join(", ")} };
`);for(const[a,u]of o.entries())e.prepend(`import * as ${u} from "${a}";
`);const c=i.getLineStarts(),p=new Set;for(const a of i.typeReferenceDirectives){p.add(a.fileName);const{line:u}=i.getLineAndCharacterOfPosition(a.pos),g=c[u];let y=i.getLineEndOfPosition(a.pos);e.slice(y,y+1)==`
`&&(y+=1),e.remove(g,y)}const m=new Set;for(const a of i.referencedFiles){m.add(T.join(T.dirname(i.fileName),a.fileName));const{line:u}=i.getLineAndCharacterOfPosition(a.pos),g=c[u];let y=i.getLineEndOfPosition(a.pos);e.slice(y,y+1)==`
`&&(y+=1),e.remove(g,y)}return{code:e,typeReferences:p,fileReferences:m};function f(a){if(r.forEachChild(a,f),r.isImportTypeNode(a)){if(!r.isLiteralTypeNode(a.argument)||!r.isStringLiteral(a.argument.literal))throw new h(a,"inline imports should have a literal argument");const u=a.argument.literal.text,g=a.getChildren(),y=g.find(E=>E.kind===r.SyntaxKind.ImportKeyword).getStart();let w=a.getEnd();const F=g.find(E=>E.kind===r.SyntaxKind.DotToken||E.kind===r.SyntaxKind.LessThanToken);F&&(w=F.getStart());const A=d(u);e.overwrite(y,w,A)}}function d(a){let u=o.get(a);return u||(u=N(a.replace(/[^a-zA-Z0-9_$]/g,()=>"_")),o.set(a,u)),u}function N(a){let u=a;for(;t.has(u);)u=`_${u}`;return t.add(u),u}function P(a,u){let g=l.get(a);if(!g)g=[u],l.set(a,g);else{const y=g[g.length-1];y[1]===u[0]?y[1]=u[1]:g.push(u)}}}function z(i,e){var t;let n=!1;const s=r.isClassDeclaration(e)||r.isFunctionDeclaration(e)||r.isModuleDeclaration(e)||r.isVariableStatement(e);for(const o of(t=e.modifiers)!==null&&t!==void 0?t:[])switch(o.kind){case r.SyntaxKind.ExportKeyword:case r.SyntaxKind.DefaultKeyword:i.remove(o.getStart(),o.getEnd()+1);break;case r.SyntaxKind.DeclareKeyword:n=!0}s&&!n&&i.appendRight(e.getStart(),"declare ")}function Te(i,e){if(!(!e.body||!r.isModuleBlock(e.body))){for(const t of e.body.statements)if(r.isExportDeclaration(t)&&t.exportClause){if(r.isNamespaceExport(t.exportClause))continue;for(const n of t.exportClause.elements)n.propertyName||i.appendLeft(n.name.getEnd(),` as ${n.name.getText()}`)}}}function _(i){const e=i.getFullStart();return e+(G(i,e)?1:0)}function W(i){const e=i.getEnd();return e+(G(i,e)?1:0)}function G(i,e){return i.getSourceFile().getFullText()[e]==`
`}const Ne=new Set([r.SyntaxKind.LiteralType,r.SyntaxKind.VoidKeyword,r.SyntaxKind.UnknownKeyword,r.SyntaxKind.AnyKeyword,r.SyntaxKind.BooleanKeyword,r.SyntaxKind.NumberKeyword,r.SyntaxKind.StringKeyword,r.SyntaxKind.ObjectKeyword,r.SyntaxKind.NullKeyword,r.SyntaxKind.UndefinedKeyword,r.SyntaxKind.SymbolKeyword,r.SyntaxKind.NeverKeyword,r.SyntaxKind.ThisKeyword,r.SyntaxKind.ThisType,r.SyntaxKind.BigIntKeyword]);class H{constructor({id:e,range:t}){if(this.scopes=[],e)this.declaration=Se(e,t);else{const{iife:n,fn:s}=xe(t);this.iife=n,this.declaration=s}}pushScope(){this.scopes.push(new Set)}popScope(e=1){for(let t=0;t<e;t++)this.scopes.pop()}pushTypeVariable(e){var t;const n=e.getText();(t=this.scopes[this.scopes.length-1])===null||t===void 0||t.add(n)}pushRaw(e){this.declaration.params.push(e)}pushReference(e){let t;if(e.type==="Identifier"?t=e.name:e.type==="MemberExpression"&&e.object.type==="Identifier"&&(t=e.object.name),t){for(const n of this.scopes)if(n.has(t))return}this.pushRaw(ge(e))}pushIdentifierReference(e){this.pushReference(v(e))}convertEntityName(e){return r.isIdentifier(e)?v(e):S({type:"MemberExpression",computed:!1,optional:!1,object:this.convertEntityName(e.left),property:v(e.right)},e)}convertPropertyAccess(e){if(!r.isIdentifier(e.expression)&&!r.isPropertyAccessExpression(e.expression))throw new h(e.expression);if(r.isPrivateIdentifier(e.name))throw new h(e.name);let t=r.isIdentifier(e.expression)?v(e.expression):this.convertPropertyAccess(e.expression);return S({type:"MemberExpression",computed:!1,optional:!1,object:t,property:v(e.name)},e)}convertComputedPropertyName(e){if(!e.name||!r.isComputedPropertyName(e.name))return;const{expression:t}=e.name;if(!r.isLiteralExpression(t)){if(r.isIdentifier(t))return this.pushReference(v(t));if(r.isPropertyAccessExpression(t))return this.pushReference(this.convertPropertyAccess(t));throw new h(t)}}convertParametersAndType(e){this.convertComputedPropertyName(e);const t=this.convertTypeParameters(e.typeParameters);for(const n of e.parameters)this.convertTypeNode(n.type);this.convertTypeNode(e.type),this.popScope(t)}convertHeritageClauses(e){for(const t of e.heritageClauses||[])for(const n of t.types)this.pushReference(I(n.expression)),this.convertTypeArguments(n)}convertTypeArguments(e){if(!!e.typeArguments)for(const t of e.typeArguments)this.convertTypeNode(t)}convertMembers(e){for(const t of e){if(r.isPropertyDeclaration(t)||r.isPropertySignature(t)||r.isIndexSignatureDeclaration(t)){this.convertComputedPropertyName(t),this.convertTypeNode(t.type);continue}if(r.isMethodDeclaration(t)||r.isMethodSignature(t)||r.isConstructorDeclaration(t)||r.isConstructSignatureDeclaration(t)||r.isCallSignatureDeclaration(t)||r.isGetAccessorDeclaration(t)||r.isSetAccessorDeclaration(t))this.convertParametersAndType(t);else throw new h(t)}}convertTypeParameters(e){if(!e)return 0;for(const t of e)this.convertTypeNode(t.constraint),this.convertTypeNode(t.default),this.pushScope(),this.pushTypeVariable(t.name);return e.length}convertTypeNode(e){if(!!e&&!Ne.has(e.kind)){if(r.isTypeReferenceNode(e)){this.pushReference(this.convertEntityName(e.typeName)),this.convertTypeArguments(e);return}if(r.isTypeLiteralNode(e))return this.convertMembers(e.members);if(r.isArrayTypeNode(e))return this.convertTypeNode(e.elementType);if(r.isTupleTypeNode(e)){for(const t of e.elements)this.convertTypeNode(t);return}if(r.isNamedTupleMember(e)||r.isParenthesizedTypeNode(e)||r.isTypeOperatorNode(e)||r.isTypePredicateNode(e))return this.convertTypeNode(e.type);if(r.isUnionTypeNode(e)||r.isIntersectionTypeNode(e)){for(const t of e.types)this.convertTypeNode(t);return}if(r.isMappedTypeNode(e)){const{typeParameter:t,type:n,nameType:s}=e;this.convertTypeNode(t.constraint),this.pushScope(),this.pushTypeVariable(t.name),this.convertTypeNode(n),s&&this.convertTypeNode(s),this.popScope();return}if(r.isConditionalTypeNode(e)){this.convertTypeNode(e.checkType),this.pushScope(),this.convertTypeNode(e.extendsType),this.convertTypeNode(e.trueType),this.convertTypeNode(e.falseType),this.popScope();return}if(r.isIndexedAccessTypeNode(e)){this.convertTypeNode(e.objectType),this.convertTypeNode(e.indexType);return}if(r.isFunctionOrConstructorTypeNode(e)){this.convertParametersAndType(e);return}if(r.isTypeQueryNode(e)){this.pushReference(this.convertEntityName(e.exprName));return}if(r.isRestTypeNode(e)){this.convertTypeNode(e.type);return}if(r.isOptionalTypeNode(e)){this.convertTypeNode(e.type);return}if(r.isTemplateLiteralTypeNode(e)){for(const t of e.templateSpans)this.convertTypeNode(t.type);return}if(r.isInferTypeNode(e)){this.pushTypeVariable(e.typeParameter.name);return}else throw new h(e)}}convertNamespace(e,t=!1){if(this.pushScope(),t&&e.body&&r.isModuleDeclaration(e.body)){this.convertNamespace(e.body,!0);return}if(!e.body||!r.isModuleBlock(e.body))throw new h(e,'namespace must have a "ModuleBlock" body.');const{statements:n}=e.body;for(const s of n){if(r.isEnumDeclaration(s)||r.isFunctionDeclaration(s)||r.isClassDeclaration(s)||r.isInterfaceDeclaration(s)||r.isTypeAliasDeclaration(s)||r.isModuleDeclaration(s)){if(s.name&&r.isIdentifier(s.name))this.pushTypeVariable(s.name);else throw new h(s,"non-Identifier name not supported");continue}if(r.isVariableStatement(s)){for(const o of s.declarationList.declarations)if(r.isIdentifier(o.name))this.pushTypeVariable(o.name);else throw new h(o,"non-Identifier name not supported");continue}if(!r.isExportDeclaration(s))throw new h(s,"namespace child (hoisting) not supported yet")}for(const s of n){if(r.isVariableStatement(s)){for(const o of s.declarationList.declarations)o.type&&this.convertTypeNode(o.type);continue}if(r.isFunctionDeclaration(s)){this.convertParametersAndType(s);continue}if(r.isInterfaceDeclaration(s)||r.isClassDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertHeritageClauses(s),this.convertMembers(s.members),this.popScope(o);continue}if(r.isTypeAliasDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertTypeNode(s.type),this.popScope(o);continue}if(r.isModuleDeclaration(s)){this.convertNamespace(s,t);continue}if(!r.isEnumDeclaration(s))if(r.isExportDeclaration(s)){if(s.exportClause){if(r.isNamespaceExport(s.exportClause))throw new h(s.exportClause);for(const o of s.exportClause.elements){const l=o.propertyName||o.name;this.pushIdentifierReference(l)}}}else throw new h(s,"namespace child (walking) not supported yet")}this.popScope()}}function De({sourceFile:i}){return new Ee(i).transform()}class Ee{constructor(e){this.sourceFile=e,this.declarations=new Map,this.ast=he(e);for(const t of e.statements)this.convertStatement(t)}transform(){return{ast:this.ast}}pushStatement(e){this.ast.body.push(e)}createDeclaration(e,t){const n={start:e.getFullStart(),end:e.getEnd()};if(!t){const c=new H({range:n});return this.pushStatement(c.iife),c}const s=t.getText(),o=new H({id:t,range:n}),l=this.declarations.get(s);if(l){l.pushIdentifierReference(t),l.declaration.end=n.end;let c=this.ast.body.findIndex(p=>p==l.declaration);for(let p=c+1;p<this.ast.body.length;p++){const m=this.ast.body[p];m.start=m.end=n.end}}else this.pushStatement(o.declaration),this.declarations.set(s,o);return l||o}convertStatement(e){if(r.isEnumDeclaration(e))return this.convertEnumDeclaration(e);if(r.isFunctionDeclaration(e))return this.convertFunctionDeclaration(e);if(r.isInterfaceDeclaration(e)||r.isClassDeclaration(e))return this.convertClassOrInterfaceDeclaration(e);if(r.isTypeAliasDeclaration(e))return this.convertTypeAliasDeclaration(e);if(r.isVariableStatement(e))return this.convertVariableStatement(e);if(r.isExportDeclaration(e)||r.isExportAssignment(e))return this.convertExportDeclaration(e);if(r.isModuleDeclaration(e))return this.convertNamespaceDeclaration(e);if(e.kind==r.SyntaxKind.NamespaceExportDeclaration)return this.removeStatement(e);if(r.isImportDeclaration(e)||r.isImportEqualsDeclaration(e))return this.convertImportDeclaration(e);throw new h(e)}removeStatement(e){this.pushStatement(S({type:"ExpressionStatement",expression:{type:"Literal",value:"pls remove me"}},e))}convertNamespaceDeclaration(e){if(e.flags&r.NodeFlags.GlobalAugmentation||!r.isIdentifier(e.name)){this.createDeclaration(e).convertNamespace(e,!0);return}const n=this.createDeclaration(e,e.name);n.pushIdentifierReference(e.name),n.convertNamespace(e)}convertEnumDeclaration(e){this.createDeclaration(e,e.name).pushIdentifierReference(e.name)}convertFunctionDeclaration(e){if(!e.name)throw new h(e,"FunctionDeclaration should have a name");const t=this.createDeclaration(e,e.name);t.pushIdentifierReference(e.name),t.convertParametersAndType(e)}convertClassOrInterfaceDeclaration(e){if(!e.name)throw new h(e,"ClassDeclaration / InterfaceDeclaration should have a name");const t=this.createDeclaration(e,e.name),n=t.convertTypeParameters(e.typeParameters);t.convertHeritageClauses(e),t.convertMembers(e.members),t.popScope(n)}convertTypeAliasDeclaration(e){const t=this.createDeclaration(e,e.name),n=t.convertTypeParameters(e.typeParameters);t.convertTypeNode(e.type),t.popScope(n)}convertVariableStatement(e){const{declarations:t}=e.declarationList;if(t.length!==1)throw new h(e,"VariableStatement with more than one declaration not yet supported");for(const n of t){if(!r.isIdentifier(n.name))throw new h(e,"VariableDeclaration must have a name");this.createDeclaration(e,n.name).convertTypeNode(n.type)}}convertExportDeclaration(e){if(r.isExportAssignment(e)){this.pushStatement(S({type:"ExportDefaultDeclaration",declaration:I(e.expression)},e));return}const t=e.moduleSpecifier?I(e.moduleSpecifier):void 0;if(!e.exportClause)this.pushStatement(S({type:"ExportAllDeclaration",source:t,exported:null},e));else if(r.isNamespaceExport(e.exportClause))this.pushStatement(S({type:"ExportAllDeclaration",source:t,exported:v(e.exportClause.name)},e));else{const n=[];for(const s of e.exportClause.elements)n.push(this.convertExportSpecifier(s));this.pushStatement(S({type:"ExportNamedDeclaration",declaration:null,specifiers:n,source:t},e))}}convertImportDeclaration(e){if(r.isImportEqualsDeclaration(e)){if(!r.isExternalModuleReference(e.moduleReference))throw new h(e,"ImportEquals should have a literal source.");this.pushStatement(S({type:"ImportDeclaration",specifiers:[{type:"ImportDefaultSpecifier",local:v(e.name)}],source:I(e.moduleReference.expression)},e));return}const t=I(e.moduleSpecifier),n=e.importClause&&e.importClause.namedBindings?this.convertNamedImportBindings(e.importClause.namedBindings):[];e.importClause&&e.importClause.name&&n.push({type:"ImportDefaultSpecifier",local:v(e.importClause.name)}),this.pushStatement(S({type:"ImportDeclaration",specifiers:n,source:t},e))}convertNamedImportBindings(e){return r.isNamedImports(e)?e.elements.map(t=>{const n=v(t.name),s=t.propertyName?v(t.propertyName):n;return{type:"ImportSpecifier",local:n,imported:s}}):[{type:"ImportNamespaceSpecifier",local:v(e.name)}]}convertExportSpecifier(e){const t=v(e.name);return{type:"ExportSpecifier",exported:t,local:e.propertyName?v(e.propertyName):t}}}function k(i,e){return r.createSourceFile(i,e,r.ScriptTarget.Latest,!0)}const we=()=>{const i=new Map,e=new Map;return{name:"dts-transform",options(t){const{onwarn:n}=t;return K(C({},t),{onwarn(s,o){s.code!="CIRCULAR_DEPENDENCY"&&(n?n(s,o):o(s))},treeshake:{moduleSideEffects:"no-external",propertyReadSideEffects:!0,unknownGlobalSideEffects:!1}})},outputOptions(t){return K(C({},t),{chunkFileNames:t.chunkFileNames||"[name]-[hash].d.ts",entryFileNames:t.entryFileNames||"[name].d.ts",format:"es",exports:"named",compact:!1,freeze:!0,interop:!1,namespaceToStringTag:!1,strict:!1})},transform(t,n){let s=k(n,t);const o=ve({sourceFile:s});i.set(s.fileName,o.typeReferences),e.set(s.fileName,o.fileReferences),t=o.code.toString(),s=k(n,t);const l=De({sourceFile:s});return process.env.DTS_DUMP_AST&&(console.log(n),console.log(t),console.log(JSON.stringify(l.ast.body,void 0,2))),{code:t,ast:l.ast,map:o.code.generateMap()}},renderChunk(t,n,s){const o=k(n.fileName,t),l=new ye(o),c=new Set,p=new Set;for(const m of Object.keys(n.modules)){for(const f of i.get(m.split("\\").join("/"))||[])c.add(f);for(const f of e.get(m.split("\\").join("/"))||[]){const d=s.file&&T.dirname(s.file)||n.facadeModuleId&&T.dirname(n.facadeModuleId)||".";let N=T.relative(d,f).split("\\").join("/");N[0]!=="."&&(N="./"+N),p.add(N)}}return t=J(Array.from(p,m=>`/// <reference path="${m}" />`)),t+=J(Array.from(c,m=>`/// <reference types="${m}" />`)),t+=l.fix(),{code:t,map:{mappings:""}}}}};function J(i){return i.length?i.join(`
`)+`
`:""}const Y=/\.(t|j)sx?$/,be=(i={})=>{const e=we(),{respectExternal:t=!1,compilerOptions:n={}}=i;let s=[];function o(l){let c,p;return!s.length&&l.endsWith($)?c=!0:(p=s.find(m=>c=m.getSourceFile(l)),!p&&r.sys.fileExists(l)&&(s.push(p=pe(l,n)),c=p.getSourceFile(l))),{source:c,program:p}}return{name:"dts",options(l){let{input:c=[]}=l;if(!Array.isArray(c))c=typeof c=="string"?[c]:Object.values(c);else if(c.length>1){l.input={};for(const p of c){let m=p.replace(/((\.d)?\.(t|j)sx?)$/,"");T.isAbsolute(p)?m=T.basename(m):m=T.normalize(m),l.input[m]=p}}return s=fe(Object.values(c),n),e.options.call(this,l)},outputOptions:e.outputOptions,transform(l,c){const p=(a,u)=>(typeof a=="object"&&(l=a.getFullText()),e.transform.call(this,l,u));if(!Y.test(c))return null;if(c.endsWith($)){const{source:a}=o(c);return a?p(a,c):null}const m=c.replace(Y,$);let f=o(m);if(f.source)return p(f.source,m);if(f=o(c),typeof f.source!="object"||!f.program)return null;let d;const{emitSkipped:N,diagnostics:P}=f.program.emit(f.source,(a,u)=>{l=u,d=p(!0,m)},void 0,!0);if(N){const a=P.filter(u=>u.category===r.DiagnosticCategory.Error);a.length&&(console.error(r.formatDiagnostics(a,R)),this.error("Failed to compile. Check the logs above."))}return d},resolveId(l,c){if(!c)return;c=c.split("\\").join("/");const{resolvedModule:p}=r.nodeModuleNameResolver(l,c,n,r.sys);if(!!p)return!t&&p.isExternalLibraryImport?{id:l,external:!0}:{id:T.resolve(p.resolvedFileName)}},renderChunk:e.renderChunk}};exports.default=be;
